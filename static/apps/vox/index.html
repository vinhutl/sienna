<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>voxiles</title>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@300;400;500;600;700&display=swap" rel="stylesheet">
    <script src="https://unpkg.com/@ruffle-rs/ruffle"></script>
    <style>
        :root {
            --bg: #111;
            --card: #1c1c1c;
            --border: #333;
            --text: #f0f0f0;
            --muted: #999;
            --highlight: #666;
            --radius: 8px;
            --shadow: 0 4px 10px rgba(0, 0, 0, 0.3);
            --gap-lg: 2.5rem;
            --gap-md: 1.5rem;
        }

        html, body {
            height: 100%;
            margin: 0;
            padding: 0;
            overflow: hidden; 
        }

        body {
            font-family: "Inter", sans-serif;
            background-color: var(--bg);
            color: var(--text);
            display: grid; 
            place-items: center; 
            padding: var(--gap-lg);
            background-image: linear-gradient(to right, var(--border) 1px, transparent 1px),
                              linear-gradient(to bottom, var(--border) 1px, transparent 1px);
            background-size: 40px 40px;
        }

        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        .container {
            display: grid; 
            gap: var(--gap-lg);
            width: 100%;
            height: 100%; 
            z-index: 10;
            grid-template-columns: 1fr; 
            grid-template-rows: auto 1fr; 
        }

        @media (min-width: 900px) {
            .container {
                grid-template-columns: 350px 1fr; 
                grid-template-rows: 1fr; 
            }
        }

        .sidebar {
            display: flex;
            flex-direction: column;
            gap: var(--gap-lg);
            flex-shrink: 0;
            overflow-y: auto; 
            padding-right: 10px; 
            scrollbar-width: thin;
            scrollbar-color: var(--highlight) transparent;
        }
        .sidebar::-webkit-scrollbar {
            width: 8px;
        }
        .sidebar::-webkit-scrollbar-track {
            background: transparent;
        }
        .sidebar::-webkit-scrollbar-thumb {
            background-color: var(--highlight);
            border-radius: 4px;
        }
        
        .main-content {
            display: flex;
            flex-direction: column;
            height: 100%;
        }
        
        .header {
            text-align: center;
        }

        .header h1 {
            font-size: 2.5rem;
            font-weight: 700;
            color: var(--text);
            letter-spacing: -1px;
        }

        .header p {
            font-size: 1rem;
            color: var(--muted);
            margin-top: 0.5rem;
        }

        .card {
            background: var(--card);
            border: 1px solid var(--border);
            border-radius: var(--radius);
            padding: var(--gap-md);
            box-shadow: var(--shadow);
            display: flex;
            flex-direction: column;
            gap: var(--gap-md);
        }
        
        .section-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        .section-header h2 {
            font-size: 1.25rem;
            font-weight: 600;
            display: flex;
            align-items: center;
            gap: 0.5rem;
        }

        .upload-area {
            border: 2px dashed var(--highlight);
            border-radius: var(--radius);
            padding: 3rem 1.5rem;
            text-align: center;
            cursor: pointer;
            transition: border-color 0.2s, background-color 0.2s;
        }

        .upload-area:hover,
        .upload-area.drag-over {
            border-color: var(--text);
            background: rgba(255, 255, 255, 0.05);
        }

        .upload-text {
            font-weight: 500;
            color: var(--text);
        }

        .upload-subtext {
            font-size: 0.85rem;
            color: var(--muted);
        }

        .upload-subtext a {
            color: var(--text);
            text-decoration: underline;
            transition: color 0.2s;
        }

        .upload-subtext a:hover {
            color: var(--highlight);
        }

        .upload-url-section {
            display: flex;
            flex-direction: column;
            gap: 0.75rem;
            margin-top: 0.5rem; 
        }

        .game-list {
            list-style: none;
            display: flex;
            flex-direction: column;
            gap: 0.5rem;
            max-height: 400px; 
            overflow-y: auto;
            scrollbar-width: thin;
            scrollbar-color: var(--highlight) transparent;
        }
        
        .game-list::-webkit-scrollbar {
            width: 8px;
        }
        
        .game-list::-webkit-scrollbar-track {
            background: transparent;
        }
        
        .game-list::-webkit-scrollbar-thumb {
            background-color: var(--highlight);
            border-radius: 4px;
        }

        .game-item {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 0.75rem 1rem;
            background: #242424;
            border-radius: var(--radius);
            border: 1px solid transparent;
            cursor: pointer;
            transition: background-color 0.2s, border-color 0.2s;
        }

        .game-item:hover {
            background: #2a2a2a;
        }
        
        .game-item.active {
            border-color: var(--text);
            background: #2a2a2a;
        }

        .game-info {
            display: flex;
            flex-direction: column;
            overflow: hidden;
            white-space: nowrap;
            text-overflow: ellipsis;
            gap: 0.25rem;
        }

        .game-info .name {
            font-weight: 500;
            color: var(--text);
            overflow: hidden;
            text-overflow: ellipsis;
        }

        .game-info .size {
            font-size: 0.8rem;
            color: var(--muted);
        }

        .game-actions {
            display: flex;
            gap: 0.5rem;
            flex-shrink: 0;
        }

        .search-container {
            margin-top: 0.5rem;
        }
        
        .search-input {
            width: 100%;
            padding: 0.75rem 1rem;
            background: #242424;
            border: 1px solid var(--border);
            border-radius: var(--radius);
            color: var(--text);
            font-size: 0.9rem;
            transition: border-color 0.2s;
        }

        .search-input::placeholder {
            color: var(--muted);
        }

        .search-input:focus {
            outline: none;
            border-color: var(--text);
        }
        
        .empty-state {
            text-align: center;
            padding: 2rem 0;
            color: var(--muted);
        }
        
        .empty-state p {
            font-weight: 500;
            margin-bottom: 0.25rem;
        }
        
        .empty-state span {
            font-size: 0.9rem;
        }

        .game-viewport {
            background: #000;
            border: 1px solid var(--border);
            border-radius: var(--radius);
            flex-grow: 1; 
            display: flex;
            flex-direction: column;
            overflow: hidden;
            box-shadow: var(--shadow);
            position: relative;
        }
        
        .game-container {
            flex-grow: 1;
            display: flex;
            flex-direction: column;
            position: relative;
            overflow: hidden;
        }
        
        .game-instance {
            width: 100%;
            height: 100%;
            display: flex;
            flex-direction: column;
            position: absolute;
            top: 0;
            left: 0;
            transition: transform 0.3s ease;
        }

        .game-instance:not(.active) {
            transform: translateY(100%);
        }

        .game-instance.active {
            transform: translateY(0);
            z-index: 10;
        }
        
.ruffle-player-wrapper {
            width: 100%;
            height: 100%;
            display: flex;
            justify-content: center;
            align-items: center;
            position: relative;
        }

        .ruffle-player-wrapper > * {
            width: 100% !important;
            height: 100% !important;
        }

        .ruffle-player-wrapper ruffle-player {
            width: 100% !important;
            height: 100% !important;
        }

        .ruffle-player-wrapper ruffle-embed {
            width: 100% !important;
            height: 100% !important;
        }

        .control-bar {
            position: absolute;
            bottom: 0;
            left: 0;
            width: 100%;
            background: rgba(0, 0, 0, 0.5);
            backdrop-filter: blur(5px);
            border-top: 1px solid var(--border);
            padding: 0.75rem 1.5rem;
            display: flex;
            justify-content: space-between;
            align-items: center;
            z-index: 2;
            transform: translateY(100%);
            transition: transform 0.3s ease;
            gap: 1rem;
        }
        
        .game-instance.active .control-bar {
            transform: translateY(0);
        }
        
        .game-info-bar {
            flex-grow: 1;
            overflow: hidden;
        }

        .game-name {
            font-size: 0.9rem;
            font-weight: 500;
            color: var(--muted);
            overflow: hidden;
            text-overflow: ellipsis;
            white-space: nowrap;
        }

        .control-buttons {
            display: flex;
            align-items: center;
            gap: 1rem;
        }

        .welcome-screen {
            text-align: center;
            color: var(--muted);
            padding: 2rem;
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            width: 100%;
            height: 100%;
            z-index: 1;
            position: absolute;
            top: 0;
            left: 0;
        }

        .welcome-screen h2 {
            font-size: 1.5rem;
            font-weight: 600;
            margin-top: 1rem;
        }

        .welcome-screen p {
            margin-top: 0.5rem;
            font-size: 1rem;
        }
        
        .stats {
            display: flex;
            justify-content: center;
            gap: 2rem;
            margin-top: 2rem;
            margin-bottom: 2rem;
        }

        .stat-item {
            text-align: center;
        }

        .stat-value {
            font-weight: 600;
            font-size: 1.5rem;
            color: var(--text);
        }

        .stat-label {
            font-size: 0.85rem;
            color: var(--muted);
        }

        .btn {
            padding: 0.6rem 1.2rem;
            border: none;
            border-radius: 6px;
            cursor: pointer;
            font-size: 0.9rem;
            font-weight: 500;
            display: inline-flex;
            align-items: center;
            gap: 0.5rem;
            transition: background-color 0.2s, transform 0.1s;
        }

        .btn:active {
            transform: scale(0.98);
        }
        
        .btn-full {
            width: 100%;
            justify-content: center;
        }

        .btn-primary {
            background: var(--text);
            color: var(--bg);
        }
        
        .btn-primary:hover {
            background: #ccc;
        }

        .btn-secondary {
            background: #242424;
            color: var(--muted);
            border: 1px solid var(--border);
        }
        
        .btn-secondary:hover {
            background: #2a2a2a;
        }
        
        .btn-sm {
            padding: 0.4rem 0.8rem;
            font-size: 0.8rem;
            border-radius: 4px;
        }
        
        .btn-danger {
            background: #545454;
            color: white;
        }
        
        .btn-danger:hover {
            background: #7e7e7e;
        }

        .notification {
            position: fixed;
            bottom: 20px;
            right: 20px;
            background: #242424;
            color: var(--text);
            padding: 1rem 1.5rem;
            border-radius: var(--radius);
            box-shadow: var(--shadow);
            z-index: 1000;
            opacity: 0;
            transform: translateY(100%);
            transition: all 0.3s ease;
        }

        .notification.show {
            opacity: 1;
            transform: translateY(0);
        }
        
        .notification.success {
            border-left: 4px solid #ffffff;
        }

        .notification.error {
            border-left: 4px solid #000000;
        }
        
        .notification.warning {
            border-left: 4px solid #676767;
        }

        .game-viewport.fullscreen-active {
            position: fixed;
            top: 0;
            left: 0;
            width: 100vw;
            height: 100vh;
            max-width: none;
            border-radius: 0;
            z-index: 1000;
            padding: 0;
            background: #000;
        }

        .game-viewport.fullscreen-active .game-container {
            width: 100%;
            height: 100%;
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
        }
        
        .game-viewport.fullscreen-active .game-instance.active {
            width: 100%;
            height: 100%;
        }

        .game-viewport.fullscreen-active .ruffle-player {
            width: 100%;
            height: 100%;
        }

        .game-viewport.fullscreen-active .control-bar {
            display: none;
        }
        
        .modal-overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.75);
            backdrop-filter: blur(5px);
            z-index: 1000;
            display: none;
            justify-content: center;
            align-items: center;
            opacity: 0;
            transition: opacity 0.3s ease;
        }

        .modal-overlay.show {
            display: flex;
            opacity: 1;
        }

        .modal-dialog {
            background: var(--card);
            border: 1px solid var(--border);
            border-radius: var(--radius);
            padding: 1.5rem;
            box-shadow: var(--shadow);
            width: 90%;
            max-width: 400px;
            display: flex;
            flex-direction: column;
            gap: 1.5rem;
            transform: scale(0.95);
            transition: transform 0.3s cubic-bezier(0.2, 0.5, 0.4, 1.2);
        }

        .modal-overlay.show .modal-dialog {
            transform: scale(1);
        }

        .modal-header h3 {
            font-size: 1.2rem;
            font-weight: 600;
            color: var(--text);
        }

        .modal-body p {
            font-size: 1rem;
            color: var(--muted);
        }

        .modal-footer {
            display: flex;
            justify-content: flex-end;
            gap: 1rem;
        }

        @media (max-width: 899px) {
            body {
                padding: var(--gap-md);
            }

            .container {
                max-height: unset; 
            }

            .header h1 {
                font-size: 2rem;
            }

            .header p {
                font-size: 0.9rem;
            }

            .card {
                padding: 1rem;
            }

            .section-header h2 {
                font-size: 1.1rem;
            }

            .upload-area {
                padding: 2rem 1rem;
            }

            .game-list {
                max-height: 300px;
            }

            .game-info .name {
                font-size: 0.9rem;
            }

            .game-info .size {
                font-size: 0.75rem;
            }

            .btn {
                padding: 0.5rem 1rem;
                font-size: 0.85rem;
            }

            .stats {
                flex-wrap: wrap;
                gap: 1rem;
            }
        }
    </style>
</head>
<body>
    <div class="container">
        <aside class="sidebar">
            <header class="header">
                <h1>voxiles</h1>
                <p>a modern, simple flash player.</p>
            </header>
            
            <section class="card">
                <div class="section-header">
                    <h2>
                        <svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-folder-plus"><path d="m22 19a2 2 0 0 1-2 2h-16a2 2 0 0 1-2-2v-14a2 2 0 0 1 2-2h5l2 3h9a2 2 0 0 1 2 2z"></path><line x1="12" y1="11" x2="12" y2="17"></line><line x1="9" y1="14" x2="15" y2="14"></line></svg>
                        upload games
                    </h2>
                </div>
                <div class="upload-area" id="upload-area">
                    <input type="file" id="file-input" accept=".swf" multiple hidden>
                    <svg xmlns="http://www.w3.org/2000/svg" width="36" height="36" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-upload"><path d="m21 15v4a2 2 0 0 1-2 2h-14a2 2 0 0 1-2-2v-4"></path><polyline points="17 8 12 3 7 8"></polyline><line x1="12" y1="3" x2="12" y2="15"></line></svg>
                    <p class="upload-text">drag & drop your swf files here</p>
                    <span class="upload-subtext">or <a href="#" id="browse-files-link">browse files</a></span>
                </div>
                <div class="upload-url-section">
                    <input type="url" id="url-input" class="search-input" placeholder="paste SWF URL here...">
                    <button class="btn btn-primary btn-full" id="upload-url-btn">
                        <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-link"><path d="M10 13a5 5 0 0 0 7.54.54l3-3a5 5 0 0 0-7.07-7.07l-1.72 1.71"></path><path d="M14 11a5 5 0 0 0-7.54-.54l-3 3a5 5 0 0 0 7.07 7.07l1.71-1.71"></path></svg>
                        upload from url
                    </button>
                </div>
            </section>
            
            <section class="card">
                <div class="section-header">
                    <h2>
                        <svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-play"><polygon points="5 3 19 12 5 21 5 3"></polygon></svg>
                        game library
                    </h2>
                    <button class="btn btn-secondary btn-sm" id="clear-all-btn">clear all</button>
                </div>
                <div class="search-container">
                    <input type="text" id="game-search" class="search-input" placeholder="search games...">
                </div>
                <div class="game-list-container">
                    <ul id="game-list" class="game-list"></ul>
                    <div class="empty-state" id="empty-state">
                        <svg xmlns="http://www.w3.org/2000/svg" width="36" height="36" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-zap"><polygon points="13 2 3 14 12 14 11 22 21 10 12 10 13 2"></polygon></svg>
                        <p>no games loaded</p>
                        <span>upload some swf files to get started.</span>
                    </div>
                </div>
            </section>
        </aside>

        <main class="main-content">
            <section class="card game-viewport" id="game-viewport">
                <div class="game-container" id="game-container">
                    <div class="welcome-screen" id="welcome-screen">
                        <svg xmlns="http://www.w3.org/2000/svg" width="64" height="64" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="1.5" stroke-linecap="round" stroke-linejoin="round" class="feather feather-monitor"><rect x="2" y="3" width="20" height="14" rx="2" ry="2"></rect><line x1="8" y1="21" x2="16" y2="21"></line><line x1="12" y1="17" x2="12" y2="21"></line></svg>
                        <h2>ready to play</h2>
                        <p>upload flash games to start your session.</p>
                        <div class="stats">
                            <div class="stat-item">
                                <span class="stat-value" id="games-loaded">0</span>
                                <span class="stat-label">games in library</span>
                            </div>
                            <div class="stat-item">
                                <span class="stat-value" id="total-size">0 mb</span>
                                <span class="stat-label">total size</span>
                            </div>
                            <div class="stat-item">
                                <span class="stat-value" id="active-games">0</span>
                                <span class="stat-label">games running</span>
                            </div>
                        </div>
                    </div>
                </div>
            </section>
        </main>
    </div>

    <div id="confirmation-modal" class="modal-overlay">
        <div class="modal-dialog">
            <div class="modal-header">
                <h3 id="modal-title"></h3>
            </div>
            <div class="modal-body">
                <p id="modal-message"></p>
            </div>
            <div class="modal-footer">
                <button class="btn btn-secondary" id="modal-cancel">cancel</button>
                <button class="btn btn-danger" id="modal-confirm">confirm</button>
            </div>
        </div>
    </div>
    

    <script>
        class SwfPlayer {
            constructor() {
                this.loadedGames = [];
                this.activeGames = [];
                this.modalPromise = null;
                this.init();
            }

            init() {
                this.bindEvents();
                this.updateStats();
                this.renderGameList();
            }

            bindEvents() {
                const uploadArea = document.getElementById('upload-area');
                const fileInput = document.getElementById('file-input');
                const browseFilesLink = document.getElementById('browse-files-link');
                const urlInput = document.getElementById('url-input'); // New
                const uploadUrlBtn = document.getElementById('upload-url-btn'); // New
                const gameList = document.getElementById('game-list');
                const gameSearch = document.getElementById('game-search');
                const clearAllBtn = document.getElementById('clear-all-btn');
                const gameContainer = document.getElementById('game-container');
                const gameViewport = document.getElementById('game-viewport');
                const modalConfirmBtn = document.getElementById('modal-confirm');
                const modalCancelBtn = document.getElementById('modal-cancel');

                browseFilesLink.addEventListener('click', (e) => {
                    e.preventDefault();
                    fileInput.click();
                });

                uploadUrlBtn.addEventListener('click', () => { 
                    const url = urlInput.value.trim();
                    if (url) {
                        this.addGameFromUrl(url);
                        urlInput.value = ''; 
                    } else {
                        this.showNotification('please enter a valid swf url', 'warning');
                    }
                });

                uploadArea.addEventListener('dragover', (e) => {
                    e.preventDefault();
                    uploadArea.classList.add('drag-over');
                });
                uploadArea.addEventListener('dragleave', () => {
                    uploadArea.classList.remove('drag-over');
                });
                uploadArea.addEventListener('drop', (e) => {
                    e.preventDefault();
                    uploadArea.classList.remove('drag-over');
                    Array.from(e.dataTransfer.files).forEach(file => this.addGame(file));
                });

                fileInput.addEventListener('change', (e) => {
                    Array.from(e.target.files).forEach(file => this.addGame(file));
                    e.target.value = '';
                });

                gameList.addEventListener('click', (e) => {
                    const gameItem = e.target.closest('.game-item');
                    if (!gameItem) return;
                    const id = parseFloat(gameItem.dataset.id);
                    const game = this.loadedGames.find(g => g.id === id);

                    if (e.target.closest('.play-btn')) {
                        this.playGame(game);
                    } else if (e.target.closest('.remove-btn')) {
                        this.removeGame(id);
                    } else {
                        this.switchToGame(id);
                    }
                });

                gameSearch.addEventListener('input', () => this.renderGameList());

                clearAllBtn.addEventListener('click', () => this.clearAll());

                gameContainer.addEventListener('click', (e) => {
                    const closeBtn = e.target.closest('.close-instance');
                    const fullscreenBtn = e.target.closest('.fullscreen-btn');
                    const activeSwf = gameContainer.querySelector('.game-instance.active');
                    
                    if (closeBtn) {
                        const instance = closeBtn.closest('.game-instance');
                        this.closeGame(parseFloat(instance.dataset.id));
                    } else if (fullscreenBtn && activeSwf) {
                        this.toggleFullscreen(gameViewport);
                    }
                });
                
                document.addEventListener('fullscreenchange', () => {
                    if (document.fullscreenElement) {
                        gameViewport.classList.add('fullscreen-active');
                    } else {
                        gameViewport.classList.remove('fullscreen-active');
                    }
                });
                
                modalConfirmBtn.addEventListener('click', () => {
                    if (this.modalPromise) {
                        this.modalPromise.resolve(true);
                        this.modalPromise = null;
                        this.hideModal();
                    }
                });

                modalCancelBtn.addEventListener('click', () => {
                    if (this.modalPromise) {
                        this.modalPromise.resolve(false);
                        this.modalPromise = null;
                        this.hideModal();
                    }
                });
            }

            addGame(file) {
                if (!file.name.toLowerCase().endsWith('.swf')) {
                    this.showNotification('please upload only swf files', 'error');
                    return;
                }

                const reader = new FileReader();
                reader.onload = (e) => {
                    const game = {
                        id: Date.now() + Math.random(),
                        name: file.name.replace(/\.swf$/i, ''),
                        size: file.size,
                        url: e.target.result 
                    };
                    this.loadedGames.push(game);
                    this.renderGameList();
                    this.updateStats();
                    this.showNotification(`added "${game.name}"`, 'success');
                };
                reader.readAsDataURL(file);
            }

            async addGameFromUrl(url) { 
                if (!url.toLowerCase().endsWith('.swf')) {
                    this.showNotification('url must end with .swf', 'error');
                    return;
                }

                this.showNotification(`fetching "${url}"...`, 'info');
                try {
                    const response = await fetch(url);
                    if (!response.ok) {
                        throw new Error(`http error! status: ${response.status}`);
                    }
                    const blob = await response.blob();

                    if (blob.type !== 'application/x-shockwave-flash') {
                        this.showNotification('fetched file is not a valid swf', 'error');
                        return;
                    }

                    const reader = new FileReader();
                    reader.onload = (e) => {
                        const filename = url.substring(url.lastIndexOf('/') + 1);
                        const game = {
                            id: Date.now() + Math.random(),
                            name: filename.replace(/\.swf$/i, ''),
                            size: blob.size,
                            url: e.target.result 
                        };
                        this.loadedGames.push(game);
                        this.renderGameList();
                        this.updateStats();
                        this.showNotification(`added "${game.name}" from url`, 'success');
                    };
                    reader.onerror = () => {
                        this.showNotification('failed to read swf data from url', 'error');
                    };
                    reader.readAsDataURL(blob);

                } catch (error) {
                    console.error("Error fetching SWF from URL:", error);
                    this.showNotification(`failed to fetch swf: ${error.message}`, 'error');
                }
            }

            playGame(game) {
                const existingInstance = this.activeGames.find(ag => ag.id === game.id);
                
                if (existingInstance) {
                    this.switchToGame(game.id);
                    return;
                }

                const welcomeScreen = document.getElementById('welcome-screen');
                welcomeScreen.style.display = 'none';

                const gameInstance = document.createElement('div');
                gameInstance.className = 'game-instance';
                gameInstance.dataset.id = game.id;
                gameInstance.innerHTML = `
                    <div class="ruffle-player-wrapper">
                        <div class="ruffle-player"></div>
                    </div>
                    <div class="control-bar">
                        <div class="game-info-bar">
                            <span class="game-name">${game.name}</span>
                        </div>
                        <div class="control-buttons">
                            <button class="btn btn-secondary btn-sm fullscreen-btn" title="fullscreen">
                                <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-maximize"><path d="m8 3h-3a2 2 0 0 0-2 2v3m18 0v-3a2 2 0 0 0-2-2h-3m0 18h3a2 2 0 0 0 2-2v-3m-18 0v3a2 2 0 0 0 2 2h3"></path></svg>
                            </button>
                            <button class="btn btn-secondary btn-sm close-instance" title="close">
                                <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-x"><line x1="18" y1="6" x2="6" y2="18"></line><line x1="6" y1="6" x2="18" y2="18"></line></svg>
                            </button>
                        </div>
                    </div>
                `;

                const rufflePlayerDiv = gameInstance.querySelector('.ruffle-player');
                document.getElementById('game-container').appendChild(gameInstance);
                
                this.switchToGame(game.id);

                try {
                    const ruffle = window.RufflePlayer.newest();
                    const player = ruffle.createPlayer();
                    rufflePlayerDiv.appendChild(player);

                    player.load({ url: game.url });

                    this.activeGames.push({
                        id: game.id,
                        name: game.name,
                        element: gameInstance,
                        player: player
                    });

                    this.updateStats();
                    this.showNotification(`playing "${game.name}"`, 'success');
                } catch (error) {
                    console.error("Error loading Ruffle player:", error);
                    gameInstance.remove();
                    this.showNotification('error loading game', 'error');
                }
            }
            
            switchToGame(id) {
                document.querySelectorAll('.game-instance').forEach(instance => {
                    instance.classList.remove('active');
                });
                const newActive = document.querySelector(`.game-instance[data-id="${id}"]`);
                if (newActive) {
                    newActive.classList.add('active');
                }
                this.updateActiveGameClass();
            }

            closeGame(id) {
                const index = this.activeGames.findIndex(game => game.id === id);
                if (index > -1) {
                    const game = this.activeGames[index];
                    const wasActive = game.element.classList.contains('active');
                    
                    game.element.remove();
                    this.activeGames.splice(index, 1);
                    this.updateStats();
                    this.showNotification(`closed "${game.name}"`, 'info');

                    if (this.activeGames.length > 0 && wasActive) {
                        this.activeGames[this.activeGames.length - 1].element.classList.add('active');
                    } else if (this.activeGames.length === 0) {
                        document.getElementById('welcome-screen').style.display = 'flex';
                    }
                    this.updateActiveGameClass();
                }
            }

            async removeGame(id) {
                const game = this.loadedGames.find(g => g.id === id);
                if (!game) return;

                const confirmed = await this.showModal('remove game', `are you sure you want to remove "${game.name}"?`);
                
                if (confirmed) {
                    this.loadedGames = this.loadedGames.filter(g => g.id !== id);
                    this.renderGameList();
                    this.updateStats();
                    this.closeGame(id);
                    this.showNotification(`removed "${game.name}"`, 'info');
                }
            }

            async clearAll() {
                const confirmed = await this.showModal('clear library', 'are you sure you want to clear all games? this action cannot be undone.');
                
                if (confirmed) {
                    this.loadedGames = [];
                    this.activeGames.forEach(game => game.element.remove());
                    this.activeGames = [];
                    this.renderGameList();
                    this.updateStats();
                    this.showNotification('library cleared', 'info');
                    
                    document.getElementById('welcome-screen').style.display = 'flex';
                }
            }
            
            renderGameList() {
                const gameList = document.getElementById('game-list');
                const gameSearch = document.getElementById('game-search').value.toLowerCase();
                
                gameList.innerHTML = '';
                
                const filteredGames = this.loadedGames.filter(game =>
                    game.name.toLowerCase().includes(gameSearch)
                );

                filteredGames.forEach(game => {
                    const li = document.createElement('li');
                    li.className = 'game-item';
                    li.dataset.id = game.id;
                    li.innerHTML = `
                        <div class="game-info">
                            <span class="name">${game.name}</span>
                            <span class="size">${this.formatSize(game.size)}</span>
                        </div>
                        <div class="game-actions">
                            <button class="btn btn-primary btn-sm play-btn" title="play">
                                <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-play"><polygon points="5 3 19 12 5 21 5 3"></polygon></svg>
                            </button>
                            <button class="btn btn-danger btn-sm remove-btn" title="remove">
                                <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-trash-2"><polyline points="3 6 5 6 21 6"></polyline><path d="m19 6v14a2 2 0 0 1-2 2h-10a2 2 0 0 1-2-2v-14m3 0v-2a2 2 0 0 1 2-2h4a2 2 0 0 1 2 2v2"></path><line x1="10" y1="11" x2="10" y2="17"></line><line x1="14" y1="11" x2="14" y2="17"></line></svg>
                            </button>
                        </div>
                    `;
                    gameList.appendChild(li);
                });

                this.updateEmptyState();
                this.updateActiveGameClass();
            }

            updateStats() {
                document.getElementById('games-loaded').textContent = this.loadedGames.length;
                const totalSize = this.loadedGames.reduce((sum, game) => sum + game.size, 0);
                document.getElementById('total-size').textContent = this.formatSize(totalSize);
                document.getElementById('active-games').textContent = this.activeGames.length;
            }

            updateEmptyState() {
                const emptyState = document.getElementById('empty-state');
                const hasFilteredGames = document.getElementById('game-list').children.length > 0;
                emptyState.style.display = hasFilteredGames ? 'none' : 'block';
            }

            updateActiveGameClass() {
                const activeGameId = this.activeGames.length > 0 ? this.activeGames[this.activeGames.length - 1].id : null;
                document.querySelectorAll('.game-item').forEach(item => {
                    const id = parseFloat(item.dataset.id);
                    if (id === activeGameId) {
                        item.classList.add('active');
                    } else {
                        item.classList.remove('active');
                    }
                });
            }

            toggleFullscreen(element) {
                if (!document.fullscreenElement) {
                    element.requestFullscreen().catch(err => {
                        this.showNotification(`error: unable to activate fullscreen mode.`, 'error');
                        console.error("Fullscreen error:", err);
                    });
                } else {
                    document.exitFullscreen();
                }
            }
            
            formatSize(bytes) {
                const units = ['b', 'kb', 'mb', 'gb'];
                let i = 0;
                while (bytes >= 1024 && i < units.length - 1) {
                    bytes /= 1024;
                    i++;
                }
                return `${bytes.toFixed(2)} ${units[i]}`;
            }

            showNotification(message, type = 'info') {
                const notification = document.createElement('div');
                notification.className = `notification ${type}`;
                notification.textContent = message;
                document.body.appendChild(notification);

                setTimeout(() => {
                    notification.classList.add('show');
                }, 10);

                setTimeout(() => {
                    notification.classList.remove('show');
                    notification.addEventListener('transitionend', () => notification.remove());
                }, 3000);
            }

            showModal(title, message) {
                const modalOverlay = document.getElementById('confirmation-modal');
                const modalTitle = document.getElementById('modal-title');
                const modalMessage = document.getElementById('modal-message');

                modalTitle.textContent = title;
                modalMessage.textContent = message;
                modalOverlay.classList.add('show');

                return new Promise((resolve) => {
                    this.modalPromise = { resolve };
                });
            }

            hideModal() {
                document.getElementById('confirmation-modal').classList.remove('show');
            }
        }

        document.addEventListener('DOMContentLoaded', () => {
            new SwfPlayer();
        });
    </script>
    <script>
        class GameLoaders {
            // Flash SWF Loader using Ruffle
            static async loadFlash(game, container) {
                try {
                    const ruffle = window.RufflePlayer.newest();
                    const player = ruffle.createPlayer();
                    container.appendChild(player);
                    await player.load({ url: game.url });
                    return { player, cleanup: () => player.remove() };
                } catch (error) {
                    throw new Error(`Flash loading failed: ${error.message}`);
                }
            }

            // HTML5 Game Loader
            static async loadHTML(game, container) {
                const iframe = document.createElement('iframe');
                iframe.src = game.url;
                iframe.style.width = '100%';
                iframe.style.height = '100%';
                iframe.style.border = 'none';
                iframe.style.background = '#000';
                iframe.setAttribute('allowfullscreen', 'true');
                iframe.setAttribute('webkitallowfullscreen', 'true');
                iframe.setAttribute('mozallowfullscreen', 'true');
                
                container.appendChild(iframe);
                return { 
                    iframe, 
                    cleanup: () => iframe.remove() 
                };
            }

            // JavaScript Game Loader
            static async loadJavaScript(game, container) {
                const gameFrame = document.createElement('div');
                gameFrame.style.width = '100%';
                gameFrame.style.height = '100%';
                gameFrame.style.background = '#000';
                gameFrame.innerHTML = `
                    <canvas id="gameCanvas-${game.id}" width="800" height="600" style="width:100%; height:100%; object-fit:contain;"></canvas>
                `;
                
                container.appendChild(gameFrame);
                
                try {
                    // Create script element and execute
                    const script = document.createElement('script');
                    const response = await fetch(game.url);
                    const jsCode = await response.text();
                    
                    // Wrap the code to provide canvas context
                    const wrappedCode = `
                        (function() {
                            const canvas = document.getElementById('gameCanvas-${game.id}');
                            const ctx = canvas.getContext('2d');
                            ${jsCode}
                        })();
                    `;
                    
                    script.textContent = wrappedCode;
                    document.head.appendChild(script);
                    
                    return { 
                        gameFrame, 
                        cleanup: () => {
                            gameFrame.remove();
                            script.remove();
                        }
                    };
                } catch (error) {
                    gameFrame.remove();
                    throw new Error(`JavaScript loading failed: ${error.message}`);
                }
            }

            // ZIP Archive Loader (extracts and loads main file)
            static async loadZIP(game, container) {
                try {
                    const response = await fetch(game.url);
                    const arrayBuffer = await response.arrayBuffer();
                    const zip = new JSZip();
                    const zipContents = await zip.loadAsync(arrayBuffer);
                    
                    // Look for main files in order of priority
                    const mainFiles = ['index.html', 'game.html', 'main.html', 'index.swf', 'game.swf'];
                    let mainFile = null;
                    
                    for (const fileName of mainFiles) {
                        if (zipContents.files[fileName]) {
                            mainFile = zipContents.files[fileName];
                            break;
                        }
                    }
                    
                    if (!mainFile) {
                        // If no main file found, use the first HTML or SWF file
                        const htmlSwfFiles = Object.keys(zipContents.files).filter(name => 
                            name.endsWith('.html') || name.endsWith('.swf')
                        );
                        if (htmlSwfFiles.length > 0) {
                            mainFile = zipContents.files[htmlSwfFiles[0]];
                        }
                    }
                    
                    if (!mainFile) {
                        throw new Error('No playable files found in ZIP archive');
                    }
                    
                    const fileData = await mainFile.async('blob');
                    const fileUrl = URL.createObjectURL(fileData);
                    
                    // Create a temporary game object for the extracted file
                    const extractedGame = {
                        ...game,
                        url: fileUrl,
                        type: mainFile.name.endsWith('.swf') ? 'swf' : 'html'
                    };
                    
                    // Load the extracted file using appropriate loader
                    const result = mainFile.name.endsWith('.swf') 
                        ? await this.loadFlash(extractedGame, container)
                        : await this.loadHTML(extractedGame, container);
                    
                    // Override cleanup to also revoke the blob URL
                    const originalCleanup = result.cleanup;
                    result.cleanup = () => {
                        originalCleanup();
                        URL.revokeObjectURL(fileUrl);
                    };
                    
                    return result;
                } catch (error) {
                    throw new Error(`ZIP loading failed: ${error.message}`);
                }
            }

            // JSON Game Config Loader (for web games with metadata)
            static async loadJSON(game, container) {
                try {
                    const response = await fetch(game.url);
                    const config = await response.json();
                    
                    if (!config.gameUrl) {
                        throw new Error('JSON config missing gameUrl field');
                    }
                    
                    // Create game object from JSON config
                    const configuredGame = {
                        ...game,
                        url: config.gameUrl,
                        name: config.title || game.name,
                        type: config.type || this.detectGameType(config.gameUrl)
                    };
                    
                    // Load the configured game
                    return await this.loadGame(configuredGame, container);
                } catch (error) {
                    throw new Error(`JSON config loading failed: ${error.message}`);
                }
            }

            // Main game loader dispatcher
            static async loadGame(game, container) {
                switch (game.type) {
                    case 'swf':
                        return await this.loadFlash(game, container);
                    case 'html':
                        return await this.loadHTML(game, container);
                    case 'js':
                        return await this.loadJavaScript(game, container);
                    case 'zip':
                        return await this.loadZIP(game, container);
                    case 'json':
                        return await this.loadJSON(game, container);
                    default:
                        throw new Error(`Unsupported game type: ${game.type}`);
                }
            }

            // Detect game type from file extension or URL
            static detectGameType(url) {
                const extension = url.split('.').pop().toLowerCase().split('?')[0];
                switch (extension) {
                    case 'swf': return 'swf';
                    case 'html': case 'htm': return 'html';
                    case 'js': return 'js';
                    case 'zip': return 'zip';
                    case 'json': return 'json';
                    default: return 'html'; // Default to HTML for unknown types
                }
            }
        }

        class SwfPlayer {
            constructor() {
                this.loadedGames = [];
                this.activeGames = [];
                this.modalPromise = null;
                this.init();
            }

            init() {
                this.bindEvents();
                this.updateStats();
                this.renderGameList();
            }

            bindEvents() {
                const uploadArea = document.getElementById('upload-area');
                const fileInput = document.getElementById('file-input');
                const browseFilesLink = document.getElementById('browse-files-link');
                const urlInput = document.getElementById('url-input');
                const uploadUrlBtn = document.getElementById('upload-url-btn');
                const gameList = document.getElementById('game-list');
                const gameSearch = document.getElementById('game-search');
                const clearAllBtn = document.getElementById('clear-all-btn');
                const gameContainer = document.getElementById('game-container');
                const gameViewport = document.getElementById('game-viewport');
                const modalConfirmBtn = document.getElementById('modal-confirm');
                const modalCancelBtn = document.getElementById('modal-cancel');

                browseFilesLink.addEventListener('click', (e) => {
                    e.preventDefault();
                    fileInput.click();
                });

                uploadUrlBtn.addEventListener('click', () => { 
                    const url = urlInput.value.trim();
                    if (url) {
                        this.addGameFromUrl(url);
                        urlInput.value = ''; 
                    } else {
                        this.showNotification('please enter a valid game url', 'warning');
                    }
                });

                uploadArea.addEventListener('dragover', (e) => {
                    e.preventDefault();
                    uploadArea.classList.add('drag-over');
                });
                uploadArea.addEventListener('dragleave', () => {
                    uploadArea.classList.remove('drag-over');
                });
                uploadArea.addEventListener('drop', (e) => {
                    e.preventDefault();
                    uploadArea.classList.remove('drag-over');
                    Array.from(e.dataTransfer.files).forEach(file => this.addGame(file));
                });

                fileInput.addEventListener('change', (e) => {
                    Array.from(e.target.files).forEach(file => this.addGame(file));
                    e.target.value = '';
                });

                gameList.addEventListener('click', (e) => {
                    const gameItem = e.target.closest('.game-item');
                    if (!gameItem) return;
                    const id = parseFloat(gameItem.dataset.id);
                    const game = this.loadedGames.find(g => g.id === id);

                    if (e.target.closest('.play-btn')) {
                        this.playGame(game);
                    } else if (e.target.closest('.remove-btn')) {
                        this.removeGame(id);
                    } else {
                        this.switchToGame(id);
                    }
                });

                gameSearch.addEventListener('input', () => this.renderGameList());

                clearAllBtn.addEventListener('click', () => this.clearAll());

                gameContainer.addEventListener('click', (e) => {
                    const closeBtn = e.target.closest('.close-instance');
                    const fullscreenBtn = e.target.closest('.fullscreen-btn');
                    const activeSwf = gameContainer.querySelector('.game-instance.active');
                    
                    if (closeBtn) {
                        const instance = closeBtn.closest('.game-instance');
                        this.closeGame(parseFloat(instance.dataset.id));
                    } else if (fullscreenBtn && activeSwf) {
                        this.toggleFullscreen(gameViewport);
                    }
                });
                
                document.addEventListener('fullscreenchange', () => {
                    if (document.fullscreenElement) {
                        gameViewport.classList.add('fullscreen-active');
                    } else {
                        gameViewport.classList.remove('fullscreen-active');
                    }
                });
                
                modalConfirmBtn.addEventListener('click', () => {
                    if (this.modalPromise) {
                        this.modalPromise.resolve(true);
                        this.modalPromise = null;
                        this.hideModal();
                    }
                });

                modalCancelBtn.addEventListener('click', () => {
                    if (this.modalPromise) {
                        this.modalPromise.resolve(false);
                        this.modalPromise = null;
                        this.hideModal();
                    }
                });
            }

            addGame(file) {
                const supportedExtensions = ['swf', 'html', 'htm', 'js', 'zip', 'json'];
                const fileExtension = file.name.split('.').pop().toLowerCase();
                
                if (!supportedExtensions.includes(fileExtension)) {
                    this.showNotification(`unsupported file type: ${fileExtension}`, 'error');
                    return;
                }

                const reader = new FileReader();
                reader.onload = (e) => {
                    const game = {
                        id: Date.now() + Math.random(),
                        name: file.name.replace(/\.(swf|html|htm|js|zip|json)$/i, ''),
                        size: file.size,
                        url: e.target.result,
                        type: GameLoaders.detectGameType(file.name)
                    };
                    this.loadedGames.push(game);
                    this.renderGameList();
                    this.updateStats();
                    this.showNotification(`added "${game.name}" (${game.type.toUpperCase()})`, 'success');
                };
                reader.readAsDataURL(file);
            }

            async addGameFromUrl(url) {
                const supportedExtensions = ['swf', 'html', 'htm', 'js', 'zip', 'json'];
                const urlExtension = url.split('.').pop().toLowerCase().split('?')[0];
                
                if (!supportedExtensions.includes(urlExtension)) {
                    this.showNotification(`unsupported url type: ${urlExtension}`, 'error');
                    return;
                }

                this.showNotification(`fetching "${url}"...`, 'info');
                try {
                    const response = await fetch(url);
                    if (!response.ok) {
                        throw new Error(`http error! status: ${response.status}`);
                    }

                    const filename = url.substring(url.lastIndexOf('/') + 1);
                    const gameType = GameLoaders.detectGameType(url);
                    
                    if (gameType === 'html' || gameType === 'js' || gameType === 'json') {
                        // For web-based games, store the URL directly
                        const game = {
                            id: Date.now() + Math.random(),
                            name: filename.replace(/\.(html|htm|js|json)$/i, ''),
                            size: 0, // Unknown size for URL-based games
                            url: url,
                            type: gameType
                        };
                        this.loadedGames.push(game);
                        this.renderGameList();
                        this.updateStats();
                        this.showNotification(`added "${game.name}" from url (${game.type.toUpperCase()})`, 'success');
                    } else {
                        // For binary files (SWF, ZIP), download and store as data URL
                        const blob = await response.blob();
                        const reader = new FileReader();
                        reader.onload = (e) => {
                            const game = {
                                id: Date.now() + Math.random(),
                                name: filename.replace(/\.(swf|zip)$/i, ''),
                                size: blob.size,
                                url: e.target.result,
                                type: gameType
                            };
                            this.loadedGames.push(game);
                            this.renderGameList();
                            this.updateStats();
                            this.showNotification(`added "${game.name}" from url (${game.type.toUpperCase()})`, 'success');
                        };
                        reader.onerror = () => {
                            this.showNotification('failed to read game data from url', 'error');
                        };
                        reader.readAsDataURL(blob);
                    }

                } catch (error) {
                    console.error("Error fetching game from URL:", error);
                    this.showNotification(`failed to fetch game: ${error.message}`, 'error');
                }
            }

            async playGame(game) {
                const existingInstance = this.activeGames.find(ag => ag.id === game.id);
                
                if (existingInstance) {
                    this.switchToGame(game.id);
                    return;
                }

                const welcomeScreen = document.getElementById('welcome-screen');
                welcomeScreen.style.display = 'none';

                const gameInstance = document.createElement('div');
                gameInstance.className = 'game-instance';
                gameInstance.dataset.id = game.id;
                gameInstance.innerHTML = `
                    <div class="ruffle-player-wrapper">
                        <div class="game-loader-container"></div>
                    </div>
                    <div class="control-bar">
                        <div class="game-info-bar">
                            <span class="game-name">${game.name} (${game.type.toUpperCase()})</span>
                        </div>
                        <div class="control-buttons">
                            <button class="btn btn-secondary btn-sm fullscreen-btn" title="fullscreen">
                                <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-maximize"><path d="m8 3h-3a2 2 0 0 0-2 2v3m18 0v-3a2 2 0 0 0-2-2h-3m0 18h3a2 2 0 0 0 2-2v-3m-18 0v3a2 2 0 0 0 2 2h3"></path></svg>
                            </button>
                            <button class="btn btn-secondary btn-sm close-instance" title="close">
                                <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-x"><line x1="18" y1="6" x2="6" y2="18"></line><line x1="6" y1="6" x2="18" y2="18"></line></svg>
                            </button>
                        </div>
                    </div>
                `;

                const gameLoaderContainer = gameInstance.querySelector('.game-loader-container');
                document.getElementById('game-container').appendChild(gameInstance);
                
                this.switchToGame(game.id);

                try {
                    const gameLoader = await GameLoaders.loadGame(game, gameLoaderContainer);

                    this.activeGames.push({
                        id: game.id,
                        name: game.name,
                        type: game.type,
                        element: gameInstance,
                        loader: gameLoader
                    });

                    this.updateStats();
                    this.showNotification(`playing "${game.name}" (${game.type.toUpperCase()})`, 'success');
                } catch (error) {
                    console.error("Error loading game:", error);
                    gameInstance.remove();
                    this.showNotification(`error loading game: ${error.message}`, 'error');
                }
            }
            
            switchToGame(id) {
                document.querySelectorAll('.game-instance').forEach(instance => {
                    instance.classList.remove('active');
                });
                const newActive = document.querySelector(`.game-instance[data-id="${id}"]`);
                if (newActive) {
                    newActive.classList.add('active');
                }
                this.updateActiveGameClass();
            }

            closeGame(id) {
                const index = this.activeGames.findIndex(game => game.id === id);
                if (index > -1) {
                    const game = this.activeGames[index];
                    const wasActive = game.element.classList.contains('active');
                    
                    // Call cleanup function if available
                    if (game.loader && game.loader.cleanup) {
                        game.loader.cleanup();
                    }
                    
                    game.element.remove();
                    this.activeGames.splice(index, 1);
                    this.updateStats();
                    this.showNotification(`closed "${game.name}"`, 'info');

                    if (this.activeGames.length > 0 && wasActive) {
                        this.activeGames[this.activeGames.length - 1].element.classList.add('active');
                    } else if (this.activeGames.length === 0) {
                        document.getElementById('welcome-screen').style.display = 'flex';
                    }
                    this.updateActiveGameClass();
                }
            }

            async removeGame(id) {
                const game = this.loadedGames.find(g => g.id === id);
                if (!game) return;

                const confirmed = await this.showModal('remove game', `are you sure you want to remove "${game.name}"?`);
                
                if (confirmed) {
                    this.loadedGames = this.loadedGames.filter(g => g.id !== id);
                    this.renderGameList();
                    this.updateStats();
                    this.closeGame(id);
                    this.showNotification(`removed "${game.name}"`, 'info');
                }
            }

            async clearAll() {
                const confirmed = await this.showModal('clear library', 'are you sure you want to clear all games? this action cannot be undone.');
                
                if (confirmed) {
                    // Clean up all active games
                    this.activeGames.forEach(game => {
                        if (game.loader && game.loader.cleanup) {
                            game.loader.cleanup();
                        }
                        game.element.remove();
                    });
                    
                    this.loadedGames = [];
                    this.activeGames = [];
                    this.renderGameList();
                    this.updateStats();
                    this.showNotification('library cleared', 'info');
                    
                    document.getElementById('welcome-screen').style.display = 'flex';
                }
            }
            
            renderGameList() {
                const gameList = document.getElementById('game-list');
                const gameSearch = document.getElementById('game-search').value.toLowerCase();
                
                gameList.innerHTML = '';
                
                const filteredGames = this.loadedGames.filter(game =>
                    game.name.toLowerCase().includes(gameSearch)
                );

                filteredGames.forEach(game => {
                    const li = document.createElement('li');
                    li.className = 'game-item';
                    li.dataset.id = game.id;
                    li.innerHTML = `
                        <div class="game-info">
                            <span class="name">${game.name} <span style="color: #666; font-size: 0.8em;">[${game.type.toUpperCase()}]</span></span>
                            <span class="size">${game.size > 0 ? this.formatSize(game.size) : 'web-based'}</span>
                        </div>
                        <div class="game-actions">
                            <button class="btn btn-primary btn-sm play-btn" title="play">
                                <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-play"><polygon points="5 3 19 12 5 21 5 3"></polygon></svg>
                            </button>
                            <button class="btn btn-danger btn-sm remove-btn" title="remove">
                                <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-trash-2"><polyline points="3 6 5 6 21 6"></polyline><path d="m19 6v14a2 2 0 0 1-2 2h-10a2 2 0 0 1-2-2v-14m3 0v-2a2 2 0 0 1 2-2h4a2 2 0 0 1 2 2v2"></path><line x1="10" y1="11" x2="10" y2="17"></line><line x1="14" y1="11" x2="14" y2="17"></line></svg>
                            </button>
                        </div>
                    `;
                    gameList.appendChild(li);
                });

                this.updateEmptyState();
                this.updateActiveGameClass();
            }

            updateStats() {
                document.getElementById('games-loaded').textContent = this.loadedGames.length;
                const totalSize = this.loadedGames.reduce((sum, game) => sum + game.size, 0);
                document.getElementById('total-size').textContent = this.formatSize(totalSize);
                document.getElementById('active-games').textContent = this.activeGames.length;
            }

            updateEmptyState() {
                const emptyState = document.getElementById('empty-state');
                const hasFilteredGames = document.getElementById('game-list').children.length > 0;
                emptyState.style.display = hasFilteredGames ? 'none' : 'block';
            }

            updateActiveGameClass() {
                const activeGameId = this.activeGames.length > 0 ? this.activeGames[this.activeGames.length - 1].id : null;
                document.querySelectorAll('.game-item').forEach(item => {
                    const id = parseFloat(item.dataset.id);
                    if (id === activeGameId) {
                        item.classList.add('active');
                    } else {
                        item.classList.remove('active');
                    }
                });
            }

            toggleFullscreen(element) {
                if (!document.fullscreenElement) {
                    element.requestFullscreen().catch(err => {
                        this.showNotification(`error: unable to activate fullscreen mode.`, 'error');
                        console.error("Fullscreen error:", err);
                    });
                } else {
                    document.exitFullscreen();
                }
            }
            
            formatSize(bytes) {
                if (bytes === 0) return '0 b';
                const units = ['b', 'kb', 'mb', 'gb'];
                let i = 0;
                while (bytes >= 1024 && i < units.length - 1) {
                    bytes /= 1024;
                    i++;
                }
                return `${bytes.toFixed(2)} ${units[i]}`;
            }

            showNotification(message, type = 'info') {
                const notification = document.createElement('div');
                notification.className = `notification ${type}`;
                notification.textContent = message;
                document.body.appendChild(notification);

                setTimeout(() => {
                    notification.classList.add('show');
                }, 10);

                setTimeout(() => {
                    notification.classList.remove('show');
                    notification.addEventListener('transitionend', () => notification.remove());
                }, 3000);
            }
            showModal(title, message) {
                const modalOverlay = document.getElementById('confirmation-modal');
                const modalTitle = document.getElementById('modal-title');
                const modalMessage = document.getElementById('modal-message');

                modalTitle.textContent = title;
                modalMessage.textContent = message;
                modalOverlay.classList.add('show');

                return new Promise((resolve) => {
                    this.modalPromise = { resolve };
                });
            }

            hideModal() {
                document.getElementById('confirmation-modal').classList.remove('show');
            }
        }

        document.addEventListener('DOMContentLoaded', () => {
            new SwfPlayer();
        });    
        </script>
    <script src="https://unpkg.com/@ruffle-rs/ruffle"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/jszip/3.10.1/jszip.min.js"></script>
</body>
</html>